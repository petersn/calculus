#!/usr/bin/python
# The calculus of constructions can be thought of, in the broadest of terms,
# as being the smallest language generated by five rewrite rules.

import functools

def union(gen):
	return reduce(lambda x, y: x | y, gen, set())

class Term:
	arities = {
		"type": 0,
		"prop": 0,
		"var": 1,
		"apply": 2,
		"lambda": 3,
		"forall": 3,
	}

	def __init__(self, kind, *args):
		assert len(args) == self.arities[kind]
		self.kind, self.args = kind, args
		if kind == "var":
			assert isinstance(self.args[0], int)
		else:
			if kind in ("lambda", "forall"):
				assert self.args[0].kind == "var"
			assert all(isinstance(arg, Term) for arg in self.args)

	def variables(self):
		if self.kind == "var":
			return set([self.args[0]])
		return union(arg.variables() for i in self.args)

	def well_scoped(self, used):
		if self.kind == "var":
			return self.args[0] in used
		args_to_recurse_on = self.args
		if self.kind in ("lambda", "forall"):
			n = self.args[0].args[0]
			if n in used:
				return False
			assert isinstance(n, int)
			used = used | set([n])
			args_to_recurse_on = args_to_recurse_on[1:]
		return all(arg.well_scoped(used) for arg in args_to_recurse_on)

	def substitute(self, var, term):
		if self == var:
			return term
		return Term(self.kind, *map(lambda t: t.substitute(var, term), self.args))

	def beta_equivalent(self, other):
		# First, get formal forms.
		pass

	def application_reduce(self):
		if self.kind == "apply":
			func, arg = self.args
			assert func.kind == "lambda"
			func_var, func_type, func_expr = func.args
			return func_expr.substitute(func_var, arg)
		return Term(self.kind, *[arg.application_reduce() for arg in self.args])

	def alpha_canonicalize(self, ):
		pass

	def __eq__(self, other):
		return self.kind == other.kind and all(i == j for i, j in zip(self.args, other.args))

	def __str__(self):
		if self.kind == "type":
			return "\xf0\x9d\x95\x8b"
		elif self.kind == "prop":
			return "\xe2\x84\x99" # u"\u2119"
		elif self.kind == "var":
			return "%i" % self.args[0]
		elif self.kind == "apply":
			return "(%s %s)" % (self.args[0], self.args[1])
		elif self.kind == "lambda":
			return "(\xce\xbb %s : %s . %s)" % (self.args[0], self.args[1], self.args[2]) # u"\u03bb"
		elif self.kind == "forall":
			return "(\xe2\x88\x80 %s : %s . %s)" % (self.args[0], self.args[1], self.args[2]) # u"\u2200"

class HasType:
	def __init__(self, term1, term2):
		self.term1, self.term2 = term1, term2
		assert isinstance(term1, Term)
		assert isinstance(term2, Term)	

	def well_scoped(self, used):
		if self.term1.kind == "var":
			# If this hastype is on a variable, then guarantee that the variable is fresh.
			if self.term1.args[0] in used:
				return False
			used = used | set([self.term1.args[0]])
		elif not self.term1.well_scoped(used):
			return False
		if not self.term2.well_scoped(used):
			return False
		return True

	def defined_vars(self):
		return set([self.term1.args[0]] if self.term1.kind == "var" else [])

	def __str__(self):
		return "%s : %s" % (self.term1, self.term2)

class Judgement:
	proven = False

	def __init__(self, context, result):
		self.context, self.result = context, result

	def sorted_context(self):
		return sorted(self.context, key=str)

	def read_context(self, term):
		for hastype in self.context:
			if term == hastype.term1:
				return hastype.term2

	def well_formed(self):
		# Check a few conditions.
		# 1) Guarantee that the dependency graph of variables referenced in the context is acyclic.
		pass
		# 2) Guarantee that each contextum is well scoped given the others. 
		# TODO: Evaluate, just the others before it? I think this is unnecessary, as acyclicness implies this.)
		for i in xrange(len(self.context)):
			others_defined = union(c.defined_vars() for c in self.context[:i] + self.context[i+1:])
			if not self.context[i].well_scoped(others_defined):
				return False
		# 3) Guarantee that all variables in the result are well scoped.
		context_defined = union(c.defined_vars() for c in self.context)
		if not self.result.well_scoped(context_defined):
			return False
		return True

	def inference_rule(f):
		@functools.wraps(f)
		def _(*args):
			# Guarantee that input judgements are well formed, and proven.
			for arg in args:
				if isinstance(arg, Judgement):
					assert arg.proven, "Input judgement to inference rule not proven!"
					assert arg.well_formed(), "Input judgement to inference rule not well formed!"
			judgement = f(*args)
			# Guarantee that the output judgement(s) are well formed, and declare them all proven.
			# The list case is entirely just for rule 3, which returns two judgements.
			if isinstance(judgement, list):
				for j in judgement:
					assert j.well_formed()
					j.proven = True
			else:
				assert judgement.well_formed()
				judgement.proven = True
			return judgement
		_ = staticmethod(_)
		return _

	@inference_rule
	def rule1(gamma):
		return Judgement(gamma, HasType(Term("prop"), Term("type")))

	@inference_rule
	def rule2(x, j):
		assert isinstance(x, Term) and x.kind == "var"
		A, K = j.result.term1, j.result.term2
		assert K.kind in ("prop", "type")
		# Here freshness is automatically handled for us by the checks of inference_rule.
		return Judgement(gamma + [HasType(x, A)], HasType(x, A))

	@inference_rule
	def rule3(x, j1, j2):
		A = j1.read_context(x)
		# Assert that x is actually in one of the contexts.
		assert A != None
		# Further assert that the contexts are the same, modulo order.
		assert j1.sorted_context() == j2.sorted_context()
		# Assert that the judgements chain like ``t : B : K''.
		assert j1.result.term2 == j2.result.term1
		t, B, K = j1.result.term1, j1.result.term2, j2.result.term2
		# ... further assert that K is either Prop or Type.
		assert K.kind in ("prop", "type")
		new_context = [contextum for contextum in j1.context if contextum.term1 != x]
		assert len(new_context) == len(j1.context) - 1, "BUG BUG BUG"
		return [
			Judgement(new_context, HasType(Term("lambda", x, A, t), Term("forall", x, A, B))),
			Judgement(new_context, HasType(Term("forall", x, A, B), K)),
		]

	@inference_rule
	def rule4(j1, j2):
		# Guarantee that the first judgement is of the form $\gamma \vdash M : (\forall x : A . B)$.
		assert j1.result.term2.kind == "forall"
		M, forall = j1.result.term1, j1.result.term2
		x, A, B = forall.args
		N, Aprime = j2.result.term1, j2.result.term2
		# Assert that A == A'
		assert A == Aprime
		# Guarantee that the two judgements have the same context.
		assert j1.sorted_context() == j2.sorted_context()
		return Judgement(j1.context, HasType(Term("apply", M, N), B.substitute(x, N)))

	@inference_rule
	def rule5(j1, j2):
		M, A = j1.result.term1, j1.result.term2
		B, K = j2.result.term1, j2.result.term2
		# Guarantee that K is either Prop or Type.
		assert K.kind in ("prop", "type")
		# Guarantee that the two judgements have the same context. (TODO: Is this necessary?)
		assert j1.sorted_context() == j2.sorted_context()
		# Require beta-equivalence of A and B.
		assert A.beta_equivalent(B)
		return Judgement(j1.context, HasType(M, B))

	def __str__(self):
		context_str = ", ".join(map(str, self.context))
		if context_str != "":
			context_str += " "
		return "%s\xe2\x8a\xa2 %s" % (context_str, self.result)

t = Term("lambda", Term("var", 1), Term("var", 2), Term("var", 1))
j = Judgement([
	HasType(Term("var", 2), Term("type"))
], HasType(t, Term("forall", Term("var", 1), Term("var", 2), Term("var", 2))))
print j
assert j.well_formed()

print Judgement.rule1([])

# Now 

